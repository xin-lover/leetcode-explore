//leetcode 790. 多米诺和托米诺平铺

#include <cstdio>
#include <vector>
#include <math.h>

using namespace std;

int numTilings(int N) {
    //思路：题目晦涩，其实就是如何用来两种瓷砖来铺满整个面板
    //根据题意，旋转后的瓷砖可认为不同
    //面板只有两列，所以L型的瓷砖必须是2的倍数，两个L型有两种铺法，且最后都是占满3列，
    //策略：根据排列组合的方式和动归的思想，dp[i]表示i列的铺满方法，dp[i+1]就有三种情况:
    //1.最后一列使用竖着排列的瓷砖，则有dp[i]种；
    //2.最后两列来排列，则有dp[i-1]*2，但如果后面1列竖着排，则与第一种情况重复，所以只需要记录横着排的情况，即dp[i-2]种
    //3.最后三列排列，则有dp[i-2]*5；同理去掉之前的情况，只有2种
    //所以递推公式:dp[i]=dp[i] + dp[i-1] + dp[i-2] * 2;
    //处理超过int最大值的情况

    if(N<=2)
    {
        return N;
    }

    vector<int> dp(N+1,1);
    dp[1]=1;
    dp[2]=2;
    int mx = pow(10,9) + 7;
    for(int i=3;i<=N;++i)
    {
        //这个思路有个问题，比如4列时, xyyz   这种情况没有考虑到
        //                         xxzz
        //dp[i] = dp[i-1] + dp[i-2] + dp[i-3]*2;

        //所以网络上的解法是把2N+1的情况也考虑进来，所以有
        //fe[n] 为2n列的方案数
        //fo[n] 为2n列+1的方案数
        //可以得到fe[n] = fe[n-1] + fe[n-2] + fe[n-3]*2 + fo[n-1] + fe[n-2];
        //fo[n] = fe[n-1]+fo[n-1]

        // long long t = static_cast<long long>(dp[i-1]) + static_cast<long long>(dp[i-2]) + static_cast<long long>(dp[i-3])*2;
        // dp[i] = t % mx;

        //网络上优化后的解法
        long long t = static_cast<long long>(dp[i-1])*2 + static_cast<long long>(dp[i-3]);
        dp[i] = t % mx;
    }

    return dp[N];
}



// 第一种情况
// 直接生成对应长度的平铺，也就是说中间不存在子长度的平铺，即此平铺是一个不可分割的整体，我们姑且叫它不可分割平铺。
// 例如：

// 长度为3的"不可分割平铺"
// XXY
// XYY
// 以下为可分割平铺：

// 能够分割为长度为2和长度为1的平铺
// XXY
// ZZY

// 能够分割为三个长度为1的平铺
// XYZ
// XYZ

// 能够分割为长度为1和长度为2的平铺
// XYY
// XZZ
// 因此我们将某一个长度为N的平铺，可以分割为一个长度为i的不可分割平铺与另外一部分长度为N-i的任意平铺，长度为N的平铺的方法总数即为：

// f(N) = sum( z(i)*f(N-i) ) (i的范围为：1-N)
// 例如，长度为4的平铺：
// 其具以下几种分割方式：

// 长度为1的不可风割平铺与长度为3的普通平铺
// 长度为2的不可风割平铺与长度为2的普通平铺
// 长度为3的不可风割平铺与长度为1的普通平铺
// 长度为4的不可风割平铺与长度为0的普通平铺
// 第一种方案的总数为：1*5=5
// 第二种方案的总数为：1*2=2
// 第三种方案的总数为：2*1=2
// 第四种方案的总数为：2*1=2

// 总数为：result = 11;
// 那么问题来了，长度为N的不可分割的平铺的总数有多少种呢？
// 答案是：

// 当N<=2时为1种
// 长度为1的“不可分割平铺”
// X
// X
// 长度为2的“不可分割平铺”
// XX
// YY
// 当N>=3是为2种
// 长度为3的不可分割平铺
// XXY
// XYY
// ----
// XYY
// XXY
// 当N一直增大时，其必须有且仅包含一对L型的多米诺，并且不能有竖直方向的2*1的多米诺。
// 我们假如在不可分割平铺的中间(不是平铺的开始或结束)包含有其他的L型的多米诺，由于L的形状可知，L的前一个位置或者后一个位置必然将此平铺分割为两个独立的平铺，因此与不可分割平铺矛盾，同样道理，也不能具有竖直方向的2*1型多米诺。又因为第一个L可以取两种情况，朝上或朝下，因此：当N>=3时有且只有2种方案将其构造为不可分割平铺
// 对应JavaScript代码为：

// var numTilings = function(N) {
//     let MOD = Math.pow(10,9) + 7;
//     let dp = new Array(N+1).fill(0);
//     dp[0] = 1;
//     dp[1] = 1;
//     dp[2] = 2;
//     for(let i=3;i<=N;i++){
//         for(let j=1;j<=i;j++){
//             dp[i]=(dp[i] + dp[i-j]*z(j)) % MOD;
//         }
//     }
//     return dp[N];
    
//     function z(i){
//         return i<=2?1:2;
//     }
// };

int main()
{
    printf("%d\n",numTilings(3));
    printf("%d\n",numTilings(4));
    return 0;
}