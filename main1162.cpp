//1162. 地图分析


#include <cstdio>
#include <vector>

using namespace std;

int maxDistance(vector<vector<int>>& grid) {
    //思路：可以考虑动归，dp[i][j]=min(dp[i-1][j],dp[i][j-1])+1
    //因为是4面，所以计算两次，一次左上，一次右下
    //4面，计算两次不够，因为左下，右上的情况没有计算，所以要计算4次

    //优化，可以两次，但需要先把数组预处理，把海洋标为inf，陆地标为0

    int m = grid.size();
    int n = m == 0 ? 0 : grid[0].size();

    vector<vector<int>> dp1(m+1,vector<int>(n+1,m*n));
    for(int i=1;i<=m;++i)
    {
        for(int j=1;j<=n;++j)
        {
            if(grid[i-1][j-1]==0)
            {
                dp1[i][j] = min(dp1[i-1][j],dp1[i][j-1]) + 1;
            }
            else
            {
                dp1[i][j]=0;
            }
            
        }
    }

    //右上-左下
    vector<vector<int>> dp2(m+1,vector<int>(n+1,m*n));
    for(int i=1;i<=m;++i)
    {
        for(int j=n-1;j>=0;--j)
        {
            if(grid[i-1][j]==0)
            {
                dp2[i][j] = min(dp2[i-1][j],dp2[i][j+1]) + 1;
            }
            else
            {
                dp2[i][j]=0;
            }
            
        }
    }

    //左下-右上
    vector<vector<int>> dp3(m+1,vector<int>(n+1,m*n));
    for(int i=m-1;i>=0;--i)
    {
        for(int j=1;j<=n;++j)
        {
            if(grid[i][j-1]==0)
            {
                dp3[i][j] = min(dp3[i+1][j],dp3[i][j-1]) + 1;
            }
            else
            {
                dp3[i][j]=0;
            }
            
        }
    }

    //右下-左上
    vector<vector<int>> dp4(m+1,vector<int>(n+1,m*n));
    int sum = 0;
    int res = 0;
    for(int i=m-1;i>=0;--i)
    {
        for(int j=n-1;j>=0;--j)
        {
            sum += grid[i][j];
            if(grid[i][j]==0)
            {
                dp4[i][j] = min(dp4[i+1][j],dp4[i][j+1]) + 1;
                int tmp1 = min(dp1[i+1][j+1],dp2[i+1][j]);
                int tmp2 = min(dp3[i][j+1],dp4[i][j]);
                res = max(res,min(tmp1,tmp2));
            }
            else
            {
                dp4[i][j] = 0;
            }
            
        }
    }

    printf("-------------\n");
    for(auto a : dp2)
    {
        for(auto b : a)
        {
            printf("%d ",b);
        }
        printf("\n");
    } 

    //全是陆地或海洋
    if(sum == 0 || sum == m*n)
    {
        return -1;
    }

    return res;
}

//另一种思路是bfs，步进
//也就是以陆地点为起点，距离为0，而海洋点的初始距离为inf，每次往外扩一步（4个方向），如果遇到海洋，则更新海洋到陆地的距离，如果是陆地，则加入步进集合

int main()
{
    vector<vector<int>> grid={
        {1,0,1},
        {0,0,0},
        {1,0,1}
    }; //2
    grid={
        {1,0,0},
        {0,0,0},
        {0,0,0}
    }; //4

    grid ={
        {0,1,1,1,1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,0,0,0,1},
    {1,0,0,0,1,1,1,0,1,0,1,0,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,0,1},
    {1,1,1,0,1,0,1,1,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,1,1,0},
    {0,0,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,1,0,1,0,0,1},
    {1,1,0,1,0,0,1,1,1,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0},
    {1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,0,1,0,1,0,0},
    {1,1,1,1,0,1,1,0,0,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0},
    {1,0,1,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,1,0,1},
    {0,0,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,0,1,1,1,0,1,0,0,1,1,0,1},
    {0,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,0,1},
    {1,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,0,1,1,0,1,0,0,1,1,0,1,0},{0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1},{0,1,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1},{0,1,0,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,1},{0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,1},{0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1},{1,1,0,0,1,0,0,1,0,0,1,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,0,1,1,0},{1,1,1,0,1,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,0,0,1},{1,1,1,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,1,1,0,1},{1,0,0,0,1,1,0,0,1,1,0,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1},{1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,1,1,1,0,1,0,1,1},{0,1,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,0},{0,0,1,0,0,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,0,0,1,1},{0,1,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,0,0,0,1},{1,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,0},{0,1,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,0,0},{0,0,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,0,1,1,0,1,1,0,1},{0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,0,1,0,1,0},{1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0},{0,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,0,1,1,1,1,1,1,0,0,1,1,0,0}};

    printf("%d\n",maxDistance(grid));
    return 0;
}