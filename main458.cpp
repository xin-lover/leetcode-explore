//458. 可怜的小猪

#include <cstdio>
#include <vector>
#include <cmath>

using namespace std;

int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
    //思路：先考虑1000只桶1个小时内的问题，因为15分钟出一次结果，那么总共可以检测4次，
    //最后一次肯定的n只桶，n只猪，一只猪对一只桶才能得出结果
    //那么同理，为了得出这n只桶，把n只桶看成一组，那么这样的组也有n个，那么检测需要两次，n+1只猪就能从n*n只桶中找到有毒的桶
    //所有问题就变成了n*n*n*n>=1000的最小值，而需要的猪数量就是n+3
    //对于通用情况下，假设检测次数是c，桶n只，那么最少猪的数量就是找到一个x，使得x的c次方>=n,x+c-1就是猪的数量
    
    //不过还可以有交叉测试的情况，也就是把桶先编号，这个就有点像二进制位的表示方法,n只猪就是n个位，那么1的位置的猪喝那个编号桶的水
    //比如3号桶，011,那么就是前两个猪都喝3号桶的水，同理，100,表示第三头猪喝第4号桶的水
    //这样，n头猪就能检测2^n个桶（注意全0表示不喝，我们不考虑这个情况）

    //对于0，我们启发了一下，也就是说6个桶，我们最多需要5只猪，因为只要5个都没事，那么第6个就是有毒的。。。
    //所以最少的情况，需要结合这两种，比如1000个桶这个，一次机会的话需要10只猪
    //而先分组的话，先分6组，1000/6个一组，用5只猪就可以分组那个组有毒，170/5再分，34/4再分，9，这里要用4只猪就够了。。。
    //但题解上只需要5只，根据我们的想法，这个行不通，那么题目中的最少就需要重新理解了
    //如果只让测试两次，输入81需要4只，而82需要5只，那我们想一下，81可以分为5组，有的组16，有的组17，对于16的组需要4只猪
    //所以我只能理解这个运气好是最少的？

    //哎，思路不对，不能按上面的思路来


    int c = minutesToTest / minutesToDie;
    int left=0,right=buckets;
    while(left<right)
    {
        int mid = left + (right-left) / 2;
        if(pow(c+1,mid) < buckets)
        {
            left = mid + 1;
        }
        else
        {
            right = mid;
        }
    }

    return left;
}

int poorPigs2(int buckets, int minutesToDie, int minutesToTest) {
    //思路：根据猪的状态来计算，对于一次测试，猪有两种状态，活或者死；
    //对于两次测试，猪可以有三种状态，活、第一次测试死、第二次测试死；
    //我们考察一次测试，如果有两只猪，那么可以测试4只桶，如果3只猪，可以测试8只桶，也就是2^n；
    //一般情况就是，x只c个状态的猪可以测试，c^x只桶
    //这种理解是从信息论角度来考虑的，状态也就是信息量，但具体如何喝还是问题？
    //还是要分组，比如4次喝水机会，有5中状态，那么两只猪能测试多少桶了？
    //根据上面的结论是25只，如何喝？
    //把25只桶排成5行5列，一只猪按行喝，一只按列喝，根据状态组合就能确定哪只桶。。。。
    //所以这里的一个误区就是容易只按一种方式分组，这样就只有时间的先后

    return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));
}

int main()
{
    printf("%d\n",poorPigs2(1000,15,60));
    printf("%d\n",poorPigs2(82,15,30));
    return 0;
}