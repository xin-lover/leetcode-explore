//1558. 得到目标数组的最少函数调用次数

#include <cstdio>
#include <vector>

using namespace std;

int minOperations(vector<int>& nums) {
    //思路：其实就是提供两个操作，一个+1，一个全体乘以2
    //奇数只能通过+1实现
    //很明显，我们可以控制什么时候给某个位置+1，这样就可以控制全体*2这个操作只作用于我们想要的位置
    //所以我们的方案就是保持最大限度的利用*2的操作，使得操作数最少，
    //考虑一下，能否先+1会比*2快，很明显，除非n=1，否则是*2快的
    //而*2的次数肯定是由nums的最大值决定的，因为我们能控制*2的位置，所以*2的数量就是可能的最大值
    //那么我们最后的操作次数就是*2操作数 + sum(nums[i]-2^k),其中2^k为最接近nums[i]且小于nums[i]的数
    //但这里有些情况需要考虑，比如12，可以2^3+1+1+1+1,也可以(2^2+1+1)*2,还可以(2+1)*2*2,明显后者少
    //所以我们如何组织操作有成了问题，可以考虑二进制表示，*2是左移，那么我们做反操作即可

    //static vector<int> powersof2 = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824};
    // int idn = 0;
    int c2 = 0;
    int res = 0;
    for(int i=0;i<nums.size();++i)
    {
        int t = nums[i];
        int c = 0;
        while(t > 0)
        {
            if(t & 1)
            {
                t -=1 ;
                ++res;
            }   
            else
            {
                t >>= 1;
                ++c;
            }
        }

        c2 = max(c2,c);
    }

    return res + c2;
}

int main()
{
    vector<int> nums = {1,5}; //5
    nums = {2,2};   //3
    nums = {4,2,5}; //6
    printf("%d\n",minOperations(nums));
    return 0;
}